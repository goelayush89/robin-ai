import { BaseAgent } from './base-agent';
import { ScreenOperator } from '../operators/screen-operator';
import { InputOperator } from '../operators/input-operator';
import { OpenAIVisionModel } from '../models/openai-vision-model';
import { AnthropicClaudeModel } from '../models/anthropic-claude-model';
import { OpenRouterModel } from '../models/openrouter-model';
import {
  AgentConfig,
  AgentCapability,
  ExecutionContext,
  ActionResult,
  ActionType,
  ModelProvider,
  OperatorType,
  AgentError,
  Screenshot,
  Action
} from '../types';

export class LocalComputerAgent extends BaseAgent {
  private screenOperator?: ScreenOperator;
  private inputOperator?: InputOperator;
  private model?: any; // AIModel interface
  private maxIterations = 10;
  private iterationDelay = 1000;

  constructor() {
    const capabilities: AgentCapability[] = [
      {
        name: 'Screen Analysis',
        description: 'Analyze screenshots and understand UI elements',
        supported: true,
        requirements: ['Vision model', 'Screen capture']
      },
      {
        name: 'Mouse Control',
        description: 'Click, drag, and scroll using mouse',
        supported: true,
        requirements: ['Input operator']
      },
      {
        name: 'Keyboard Control',
        description: 'Type text and press keyboard shortcuts',
        supported: true,
        requirements: ['Input operator']
      },
      {
        name: 'Multi-step Tasks',
        description: 'Execute complex tasks with multiple steps',
        supported: true,
        requirements: ['Vision model', 'All operators']
      },
      {
        name: 'Error Recovery',
        description: 'Detect and recover from errors',
        supported: true,
        requirements: ['Vision model']
      }
    ];

    super(
      'local-computer-agent',
      'Local Computer Agent',
      'AI agent for controlling local computer through GUI automation',
      capabilities
    );
  }

  protected async onInitialize(config: AgentConfig): Promise<void> {
    try {
      // Initialize operators
      this.screenOperator = new ScreenOperator();
      await this.screenOperator.initialize(config.operator.settings);

      this.inputOperator = new InputOperator();
      await this.inputOperator.initialize(config.operator.settings);

      // Initialize AI model
      await this.initializeModel(config);

      // Set agent settings
      this.maxIterations = config.settings.maxIterations || 10;
      this.iterationDelay = config.settings.iterationDelay || 1000;

      this.log('info', 'Local computer agent initialized successfully');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new AgentError(`Failed to initialize local computer agent: ${errorMessage}`, { error });
    }
  }

  protected async onExecute(instruction: string, context: ExecutionContext): Promise<ActionResult[]> {
    const results: ActionResult[] = [];
    let currentIteration = 0;
    let lastScreenshot: Screenshot | undefined;

    try {
      this.log('info', 'Starting task execution', { instruction, maxIterations: this.maxIterations });

      while (currentIteration < this.maxIterations) {
        currentIteration++;
        this.emitEvent('iteration-started', { iteration: currentIteration, instruction });

        // Capture current screen state
        if (!this.screenOperator) {
          throw new AgentError('Screen operator not initialized');
        }

        lastScreenshot = await this.screenOperator.capture();
        this.emitEvent('screenshot-captured', { screenshot: lastScreenshot, iteration: currentIteration });

        // Analyze screenshot and get next actions
        const response = await this.model.analyze(
          lastScreenshot.data,
          instruction,
          {
            ...context,
            screenshot: lastScreenshot,
            previousActions: results.map(r => r.data?.action).filter(Boolean)
          }
        );

        this.emitEvent('analysis-completed', { 
          response, 
          iteration: currentIteration,
          reasoning: response.reasoning 
        });

        if (!response.actions || response.actions.length === 0) {
          this.log('warn', 'No actions generated by model', { iteration: currentIteration });
          break;
        }

        // Execute each action
        for (const action of response.actions) {
          this.emitEvent('action-started', { action, iteration: currentIteration });

          // Check if task is finished
          if (action.type === ActionType.FINISHED) {
            this.log('info', 'Task marked as finished by model');
            results.push(this.createActionResult(action.id, true, undefined, { 
              action, 
              finished: true 
            }));
            return results;
          }

          // Check if user input is needed
          if (action.type === ActionType.CALL_USER) {
            this.emitEvent('user-input-requested', { 
              message: action.parameters.message,
              action,
              iteration: currentIteration 
            });
            results.push(this.createActionResult(action.id, true, undefined, { 
              action,
              userInputRequested: true,
              message: action.parameters.message
            }));
            return results;
          }

          // Validate action before execution
          const validation = await this.model.validateAction(action, {
            ...context,
            screenshot: lastScreenshot
          });

          if (!validation.valid) {
            const errorMsg = `Action validation failed: ${validation.errors.join(', ')}`;
            this.log('error', errorMsg, { action, validation });
            results.push(this.createActionResult(action.id, false, errorMsg, { action }));
            continue;
          }

          // Execute the action
          let actionResult: ActionResult;
          
          if (this.isScreenAction(action.type)) {
            actionResult = await this.screenOperator.execute(action);
          } else if (this.isInputAction(action.type)) {
            if (!this.inputOperator) {
              throw new AgentError('Input operator not initialized');
            }
            actionResult = await this.inputOperator.execute(action);
          } else {
            actionResult = this.createActionResult(
              action.id, 
              false, 
              `Unsupported action type: ${action.type}`,
              { action }
            );
          }

          results.push(actionResult);
          this.emitEvent('action-completed', { action, result: actionResult, iteration: currentIteration });

          // If action failed, log and continue
          if (!actionResult.success) {
            this.log('warn', 'Action execution failed', { 
              action, 
              error: actionResult.error,
              iteration: currentIteration 
            });
          }

          // Wait between actions if configured
          if (this.iterationDelay > 0) {
            await new Promise(resolve => setTimeout(resolve, this.iterationDelay));
          }
        }

        this.emitEvent('iteration-completed', { 
          iteration: currentIteration, 
          actionsExecuted: response.actions.length,
          results: results.slice(-response.actions.length)
        });

        // Check if we should continue
        const shouldContinue = await this.shouldContinueExecution(results, response);
        if (!shouldContinue) {
          this.log('info', 'Stopping execution based on analysis');
          break;
        }
      }

      if (currentIteration >= this.maxIterations) {
        this.log('warn', 'Maximum iterations reached', { maxIterations: this.maxIterations });
        this.emitEvent('max-iterations-reached', { maxIterations: this.maxIterations, results });
      }

      return results;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.log('error', 'Execution failed', { error: errorMessage, iteration: currentIteration });
      
      // Add error result
      results.push(this.createActionResult(
        this.generateId(),
        false,
        errorMessage,
        { error, iteration: currentIteration }
      ));
      
      throw new AgentError(`Execution failed at iteration ${currentIteration}: ${errorMessage}`, { 
        error, 
        results,
        iteration: currentIteration 
      });
    }
  }

  protected async onPause(): Promise<void> {
    this.log('info', 'Local computer agent paused');
    this.emitEvent('agent-paused', {});
  }

  protected async onResume(): Promise<void> {
    this.log('info', 'Local computer agent resumed');
    this.emitEvent('agent-resumed', {});
  }

  protected async onStop(): Promise<void> {
    try {
      if (this.screenOperator) {
        await this.screenOperator.cleanup();
        this.screenOperator = undefined;
      }

      if (this.inputOperator) {
        await this.inputOperator.cleanup();
        this.inputOperator = undefined;
      }

      if (this.model) {
        await this.model.cleanup();
        this.model = undefined;
      }

      this.log('info', 'Local computer agent stopped and cleaned up');
    } catch (error) {
      this.log('warn', 'Error during cleanup', { error });
    }
  }

  private async initializeModel(config: AgentConfig): Promise<void> {
    switch (config.model.provider) {
      case ModelProvider.OPENAI:
        this.model = new OpenAIVisionModel();
        break;
      case ModelProvider.ANTHROPIC:
        this.model = new AnthropicClaudeModel();
        break;
      case ModelProvider.CUSTOM:
        this.model = new OpenRouterModel();
        break;
      default:
        throw new AgentError(`Unsupported model provider: ${config.model.provider}`);
    }

    await this.model.initialize(config.model);
    this.log('info', 'AI model initialized', { provider: config.model.provider, name: config.model.name });
  }

  private isScreenAction(actionType: ActionType): boolean {
    return actionType === ActionType.SCREENSHOT;
  }

  private isInputAction(actionType: ActionType): boolean {
    return [
      ActionType.CLICK,
      ActionType.DOUBLE_CLICK,
      ActionType.RIGHT_CLICK,
      ActionType.DRAG,
      ActionType.TYPE,
      ActionType.KEY,
      ActionType.SCROLL,
      ActionType.WAIT
    ].includes(actionType);
  }

  private async shouldContinueExecution(results: ActionResult[], lastResponse: any): Promise<boolean> {
    // Check if recent actions were successful
    const recentResults = results.slice(-3);
    const successRate = recentResults.filter(r => r.success).length / recentResults.length;
    
    if (successRate < 0.5) {
      this.log('warn', 'Low success rate, considering stopping', { successRate });
      return false;
    }

    // Check model confidence
    if (lastResponse.confidence < 0.3) {
      this.log('warn', 'Low model confidence, considering stopping', { confidence: lastResponse.confidence });
      return false;
    }

    return true;
  }

  // Public methods for external control
  public async takeScreenshot(): Promise<Screenshot> {
    if (!this.screenOperator) {
      throw new AgentError('Screen operator not initialized');
    }
    return this.screenOperator.capture();
  }

  public async executeAction(action: Action): Promise<ActionResult> {
    if (this.isScreenAction(action.type)) {
      if (!this.screenOperator) {
        throw new AgentError('Screen operator not initialized');
      }
      return this.screenOperator.execute(action);
    } else if (this.isInputAction(action.type)) {
      if (!this.inputOperator) {
        throw new AgentError('Input operator not initialized');
      }
      return this.inputOperator.execute(action);
    } else {
      throw new AgentError(`Unsupported action type: ${action.type}`);
    }
  }

  public getModelInfo(): any {
    return this.model ? {
      provider: this.model.provider,
      name: this.model.name,
      version: this.model.version,
      isInitialized: this.model.isInitialized
    } : null;
  }
}
